<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>图的遍历</title>
  <link rel="stylesheet" href="./css/sort.css">
  <link rel="stylesheet" href="../css/sn.css">
  <base target="_blank">

</head>

<body>
  <header></header>
  <main>
    <h1>图的遍历</h1>
    <h5>Graph Traverse</h5>
    <dd><img src="./graph/chap6graph/幻灯片36.JPG" alt="" loading="lazy" decoding="async"></dd>
    <div class="chap">DFS</div>
    <dl>
      <dt>说明</dt>
      <dd>. 用于查找节点之间是否有路径</dd>
      <dd><img src="./graph/chap6graph/幻灯片37.JPG" alt="" loading="lazy" decoding="async"></dd>
      <dd><img src="./graph/chap6graph/幻灯片38.JPG" alt="" loading="lazy" decoding="async"></dd>
      <dt>算法</dt>
      <dd>. 借助栈实现</dd>
      <dd>. 访问过的节点，如它有邻接节点没有被访问，就入栈；如果它的邻接节点都访问过了，就出栈</dd>
      <dd>. 依次判断栈顶，是否还有邻接节点没有被访问；如果没有，出栈，直到栈为空</dd>
      <dd>. 遍历结束</dd>
      <dd>. DFS一查到底</dd>
      <dd>. 更多信息，请查看 <a href="https://www.hackerearth.com/practice/algorithms/graphs/depth-first-search/tutorial/"
          class="warn">DFS算法</a>、<a
          href="https://www.bilibili.com/video/BV1Gv4y1Q7wB/?p=21&spm_id_from=pageDriver&vd_source=fe13480e1099e18e9d5f4e25467df4df">DFS原理</a>
      </dd>
    </dl>
    <div class="chap">BFS</div>
    <dl>
      <dt>说明</dt>
      <dd>. 用于查找节点之间的最短路径</dd>
      <dd><img src="./graph/chap6graph/幻灯片39.JPG" alt="" loading="lazy" decoding="async"></dd>
      <dd><img src="./graph/chap6graph/幻灯片40.JPG" alt="" loading="lazy" decoding="async"></dd>
      <dd><img src="./graph/chap6graph/幻灯片41.JPG" alt="" loading="lazy" decoding="async"></dd>
      <dd><img src="./graph/chap6graph/幻灯片42.JPG" alt="" loading="lazy" decoding="async"></dd>
      <dt>算法</dt>
      <dd>. 借助队列实现</dd>
      <dd>. 每次访问一个节点，把邻接的节点入队</dd>
      <dd>. 不管是DFS还是BFS，都需要指定第一个访问的顶点</dd>
      <dd>. 更多信息，请查看 <a href="https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/tutorial/"
          class="warn">BFS算法</a>、<a
          href="https://www.bilibili.com/video/BV1Xg411E7Np/?p=20&spm_id_from=pageDriver">BFS原理</a></dd>
      <dd class="example-sn">在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（B）倍。</dd>
      <dd class="alpha">
        <div>1/2 </div>
        <div>1</div>
        <div>2</div>
        <div>4</div>
      </dd>
      <dd class="example-sn">若从无向图的任意一个顶点出发进行一次深度优先搜索可以访问图中所有的顶点，则该图一定是（A）图。</dd>
      <dd class="alpha">
        <div>连通 </div>
        <div>非连通 </div>
        <div>强连通 </div>
        <div>有向</div>
      </dd>
      <dd class="example-sn">具有n个顶点的有向图最多有（B）条边。</dd>
      <dd class="alpha">
        <div>n</div>
        <div>n(n-1) </div>
        <div>n(n+1) </div>
        <div>n<sup>2</sup></div>
      </dd>
      <dd class="example-sn">图的深度优先遍历类似于二叉树的（A）。</dd>
      <dd class="alpha">
        <div>先序遍历 </div>
        <div>中序遍历 </div>
        <div>后序遍历 </div>
        <div>层次遍历</div>
      </dd>
      <dd class="example-sn">有8个结点的无向完全图,边的条数是(B)。</dd>
      <dd class="alpha">
        <div>14 </div>
        <div>28 </div>
        <div>56 </div>
        <div>112</div>
      </dd>
      <dd class="example-sn">设某有向图中有n个顶点,则该有向图对应的邻接表中的表头节点个数为（C）。</dd>
      <dd class="alpha">
        <div>n-1 </div>
        <div>n+2 </div>
        <div>n </div>
        <div>n+1</div>
      </dd>
      <dd class="example-sn">图的邻接表比邻接矩阵更便于统计边的数目。(√)</dd>
      <dd class="example-sn">图的邻接矩阵一定是对称的。(×) </dd>
      <dd class="example-sn">无向图的邻接矩阵一定是对称的。(√) </dd>
      <dd class="example-sn">用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。 (√)</dd>
    </dl>
    <div id="footer"></div>
    <script src="/utils/custom/footer.js"></script>
  </main>
</body>

</html>