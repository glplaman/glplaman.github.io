<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>运算符 Operator</title>
    <link rel="stylesheet" href="../css/normalizeNew.css">
    <link rel="stylesheet" href="./css/style.css">
    <style>
        header {
            background-color: #fed;
            background-image: url(./imgs/idea.png);
            background-position: right top;
            justify-content: space-between;
        }

        .iconfont,
        .warn {
            color: #6fbe2e;
        }

        .p50 {
            width: 50%;
        }

        .bgc-gray {
            background: #fed;
        }
    </style>
</head>

<body class="container">
    <div class="w cont layout" id="top">
        <header>
        </header>
        <nav>
            <h1 class="logo">Operator</h1>
            <ul class="nav-box">
                <li class="nav-item">赋值</li>
                <li class="nav-item">算术</li>
                <li class="nav-item">关系</li>
                <li class="nav-item">逻辑</li>
                <li class="nav-item">三元</li>
                <li class="nav-item">位</li>
                <li class="hot-spot"></li>
            </ul>
        </nav>
        <div class="cont-wrap">
            <div class="chap">基本概念</div>
            <dl>
                <dt>运算符</dt>
                <dd>执行某种运算的符号</dd>
                <dt>操作数</dt>
                <dd>参与运算的数据，可以是变量、常量等</dd>
                <dt>表达式</dt>
                <dd>运算符和操作数的结合；表达式也可以作为操作数</dd>
                <dt>运算符类型</dt>
                <dd>根据操作数个数/元来分：</dd>
                <dd>
                    <table>
                        <tr>
                            <td>一元运算符!</td>
                            <td>二元运算符</td>
                            <td>三元运算符?</td>
                        </tr>
                    </table>
                </dd>
                <dd>根据运算符类型来分：</dd>
                <dd>
                    <table>
                        <tr>
                            <td>赋值运算符</td>
                            <td>算术运算符</td>
                        </tr>
                        <tr>
                            <td>关系运算符</td>
                            <td>逻辑运算符</td>
                        </tr>
                        <tr>
                            <td>三元运算符</td>
                            <td>位运算符</td>
                        </tr>
                    </table>
                </dd>
            </dl>
        </div>
        <div class="cont-wrap nav-cont">
            <div class="chap">赋值运算符 Assignment Operators</div>
            <dl>
                <dt>基本赋值运算符 (=)</dt>
                <dd>. 将右边的操作数运算后，赋值给左边的操作数[变量]</dd>
                <dd></dd>
                <dt>扩展赋值运算符 (+=) (-=) (*=) (/=) (%=)</dt>
                <dd>. 为了简化表达式，如 a=a+b可以简化位 a+=b；为了增加代码的可读性，也可以不使用</dd>
                <dd>. 左边和右边的操作数都参与运算</dd>
                <dd>. 将左边的操作数和右边的操作数运算后，赋值给左边的操作数[变量]</dd>
                <dd>. 声明变量的同时，不能使用，如 int a+=b</dd>
                <dd class="mt2">[<span class="iconfont icon-border-warn"></span>]说明</dd>
                <dd>. 大多数运算符的结合都是从左向右；赋值运算符是从右向左</dd>
                <dd>. 赋值时会强制类型转换；下例中，byte运算时会提升为int，所以赋值时必须再强制转换为byte</dd>
                <dd>
                    <pre>
class Precious {
    public static void main(String[] args) {
        byte a = 10;
        byte b = 20;
        byte res = (byte) (a + b);
        System.out.println(res);
    }
}</pre>
                </dd>
                <dd>. 也可以使用扩展运算符，无需类型转换</dd>
                <dd>
                    <pre>
class Precious {
    public static void main(String[] args) {
        byte b = 20;
        byte res = 0;
        res += b;
        System.out.println(res);
    }
}</pre>
                </dd>
            </dl>
        </div>
        <div class="cont-wrap nav-cont">
            <div class="chap">算术运算符 Arithmetic Operators</div>
            <dl>
                <dd>. 适合数值类型的数据：除了布尔类型，其它基本数据类型都可以使用算术运算符</dd>
                <dt>加法(+) 减法(-) 乘法(*) 除法(/) 取余(%)</dt>
                <dd>. 被除数/除数=商...余数：除法/是求商数；取余%是求余数</dd>
                <dd>
                    <pre>
class Arithmetic {
    public static void main(String[] args) {
        int a = 5;
        int b = 3;
        System.out.printf("%d + %d = %d\n", a, b, a + b);
        System.out.printf("%d - %d = %d\n", a, b, a - b);
        System.out.printf("%d * %d = %d\n", a, b, a * b);
        System.out.printf("%d / %d = %d\n", a, b, a / b);
        System.out.printf("%d %% %d = %d\n", a, b, a % b);
    }
}</pre>
                </dd>
                <dt>自增(++) 自减(--)</dt>
                <dd>. 自增(++)、自减(--)只能使用变量，不能使用常量</dd>
                <dd>. 变量可以在运算符左边；也可以在运算符右边，如：变量++、--变量</dd>
                <dd>. 单独使用：仅仅实现变量的自增或自减，如循环体中的++i或i++</dd>
                <dd>. 组合使用：作为一个表达式使用；变量++是先使用变量再自增；++变量是先自增再使用变量</dd>
                <dd>
                    <pre>
class IncDec {
    public static void main(String[] args) {
        int a = 3;
        a++;
        int b = 3;
        ++b;
        System.out.println(a);//4
        System.out.println(b);//4
        int c = 3;
        System.out.println(c++);//3
        int d = 3;
        System.out.println(++d);//4
    }
}</pre>
                </dd>
                <dd class="mt2">[<span class="iconfont icon-tixing"></span>]说明</dd>
                <dd>. (+)还可以用作字符串的拼接</dd>
                <dd>. 多个自增/自减使用时，不同编译器的执行结果不尽相同，请勿炫技，代码是给人看的</dd>
                <dd class="mt2">[<span class="iconfont icon-jianpan"></span>]数字反转：6789 → 8976</dd>
                <dd>
                    <pre>
class Inverse {
    public static void main(String[] args) {
        int a = 6789;
        System.out.println(a);
        int unit = a % 10;
        int ten = a / 10 % 10;
        int hund = a / 100 % 10;
        int thou = a / 1000 % 10;
        System.out.println(unit + "-" + ten + "-" + hund + "-" + thou);
        System.out.println(unit * 1000 + ten * 100 + hund * 10 + thou);
    }
}</pre>
                </dd>
            </dl>
        </div>
        <div class="cont-wrap nav-cont">
            <div class="chap">关系运算符 Relational Operators</div>
            <dl>
                <dt>大于(>) 小于(&lt;) 大于等于(>=) 小于等于(&lt;=) 不等于(!=) 等于(==)</dt>
                <dd>. 结果是布尔类型，true或false</dd>
                <dd>. 操作数是数值类型的数据；布尔类型没有大小之分</dd>
                <dd>. (==)和(!=)的操作数可以是引用数据类型</dd>
                <dd>. (==)和(!=)对基本数据类型而言，比较的是数值是否相等；对引用数据类型而已，比较的是引用的地址是否相等</dd>
            </dl>
        </div>
        <div class="cont-wrap nav-cont">
            <div class="chap">逻辑运算符 Logical Operators</div>
            <dl>
                <dt>短路与(&&) 短路或(||) 非(!) 异或(^) </dt>
                <dd>短路与(&&)：只要有一个false，结果就是false</dd>
                <dd>短路或(||)：只要有一个true，结果就是true</dd>
                <dd>非(!)：取反；!true=false; !false=true</dd>
                <dd>异或(^)：相同为false；不同为true</dd>
                <dd>. 操作数必须是布尔类型</dd>
                <dd>. 结果也是布尔类型</dd>
                <dd>. 除了非(!)外，都需要2个操作数</dd>
                <dd>. 注意同位运算符区分：与(&) 或(|)</dd>
                <dd class="mt2">[<span class="iconfont icon-jianpan"></span>]短路特性</dd>
                <dd>. 先使用a再自增，使用a=10>10不成立，后面就不再执行，b仍然为5，结果为false</dd>
                <dd>
                    <pre>
class Logical {
    public static void main(String[] args) {
        int a = 10;
        int b = 5;
        boolean bool = a++ > 10 && b-- &lt; 20;
        System.out.println("a=" + a);
        System.out.println("b=" + b);
        System.out.println("bool=" + bool);
    }
}</pre>
                </dd>
            </dl>
        </div>
        <div class="cont-wrap nav-cont">
            <div class="chap">三元运算符 Ternary Operators</div>
            <dl>
                <dt>布尔表达式 ? 表达式1 : 表达式2</dt>
                <dd>. 如果布尔表达式真，执行表达式1.否则执行表达式2</dd>
                <dd>. 如果有变量接受运算结果，变量、表达式1和表达式2的结果类型应保持一致；如果不满足自动类型转换，将报错</dd>
                <dd>. 如果单独使用三元表达式，数据类型不做要求[不推荐]</dd>
                <dd>
                    <pre>
class Ternary {
    public static void main(String[] args) {
        int a = 10;
        int b = 5;
        System.out.println("max=" + (a > b ? a : b));
        System.out.println("min=" + (a &lt; b ? a : b));
        double res0 = a > b ? 10.0 : 2;
        int res1 = a > b ? 10 : 20.0;//Type mismatch: cannot convert from double to int
        int res2 = a &lt; b ? 10.0 : 20;//Type mismatch: cannot convert from double to int
    }
}</pre>
                </dd>
                <dd>[<span class="iconfont icon-wenq warn"></span>]求三个数中的最大值和最小值</dd>
            </dl>
        </div>
        <div class="cont-wrap nav-cont">
            <div class="chap">位运算符 Bit Operators</div>
            <dl>
                <dd>. 按位运算</dd>
                <dd>. 基于二进制的补码；计算的时候要转为补码；获取结果的时候要转为原码</dd>
                <dd>. 执行效率最高；但是可读性不好</dd>
                <dd>. 多用于单片机和嵌入式开发；更多信息，请参考 <a class="warn" href="../wsn/index.html" target="_blank">无线传感网WSN</a>
                    的实验部分或其它相关文档</dd>
                <dt>与(&)</dt>
                <dd>. 双目操作符</dd>
                <dd>. 有1个为0，结果就为0</dd>
                <dd>
                    <table>
                        <tr>
                            <td class="p50 bgc-gray">&</td>
                            <td class="p50 bgc-gray">结果</td>
                        </tr>
                        <tr>
                            <td>0 & 0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>0 & 1</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>1 & 0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>1 & 1</td>
                            <td>1</td>
                        </tr>
                    </table>
                </dd>
                <dt>或(|)</dt>
                <dd>. 双目操作符</dd>
                <dd>. 有1个为1，结果就为1</dd>
                <dd>
                    <table>
                        <tr>
                            <td class="p50 bgc-gray">|</td>
                            <td class="p50 bgc-gray">结果</td>
                        </tr>
                        <tr>
                            <td>0 | 0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>0 | 1</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>1 | 0</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>1 | 1</td>
                            <td>1</td>
                        </tr>
                    </table>
                </dd>
                <dt>异或(^)</dt>
                <dd>. 双目操作符</dd>
                <dd>. 相同为0，不同为1</dd>
                <dd>
                    <table>
                        <tr>
                            <td class="p50 bgc-gray">^</td>
                            <td class="p50 bgc-gray">结果</td>
                        </tr>
                        <tr>
                            <td>0 | 0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>0 | 1</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>1 | 0</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>1 | 1</td>
                            <td>0</td>
                        </tr>
                    </table>
                </dd>
                <dt>取反(~)</dt>
                <dd>. 单目运算符，也叫一元运算符</dd>
                <dd>
                    <table>
                        <tr>
                            <td class="p50 bgc-gray">~</td>
                            <td class="p50 bgc-gray">结果</td>
                        </tr>
                        <tr>
                            <td>~0</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>~1</td>
                            <td>0</td>
                        </tr>
                    </table>
                </dd>
                <dd>
                    <pre>
class Bit {
    public static void main(String[] args) {
        int a = 255;
        int b = 15;
        // 都是补码；正数的原码和补码相同
        // 0000 0000 0000 0000 0000 0000 1111 1111 a
        // 0000 0000 0000 0000 0000 0000 0000 1111 b
        // 0000 0000 0000 0000 0000 0000 0000 1111 a & b
        System.out.println("res=" + (a & b));
        int c = 254;
        // 0000 0000 0000 0000 0000 0000 1111 1110 正数原码=反码=补码
        // 取反后
        // 1111 1111 1111 1111 1111 1111 0000 0001
        // 结果调整[取反后符号为1，是负数]
        // 1111 1111 1111 1111 1111 1111 0000 0000 反码=补码-1
        // 1000 0000 0000 0000 0000 0000 1111 1111 原码=反码取反[除符号位外]
        System.out.println("res=" + (~c));
        int d = -245;
        // 1000 0000 0000 0000 0000 0000 1111 0101 原码[第一位是符号位，正数为0；负数为1]
        // 1111 1111 1111 1111 1111 1111 0000 1010 反码=原码取反[除符号位外]
        // 1111 1111 1111 1111 1111 1111 0000 1011 补码=反码+1
        // 0000 0000 0000 0000 0000 0000 1111 0100 ~[取反后符号为0，是正数]
        System.out.println("res=" + (~d));
    }
}</pre>
                </dd>
                <dt>左移(&lt;&lt;)</dt>
                <dd>. 有符号：左移会丢失符号位；右边补0；每左移1位，相当于*2</dd>
                <dd>
                    <pre>
class LeftMove {
    public static void main(String[] args) {
        System.out.println("res=" + (10 &lt;&lt; 2));//40
        // 1000 0000 0000 0000 0000 0000 0000 1010 原码
        // 1111 1111 1111 1111 1111 1111 1111 0101 反码
        // 1111 1111 1111 1111 1111 1111 1111 0110 补码
        // 11 1111 1111 1111 1111 1111 1111 0110 00 &lt;&lt;2
        // 11 1111 1111 1111 1111 1111 1111 0101 11 反码
        // 10 0000 0000 0000 0000 0000 0000 1010 00 原码
        System.out.println("res=" + (-10 &lt;&lt; 2));//-40
    }
}</pre>
                </dd>
                <dt>右移(>>)</dt>
                <dd>. 有符号：右移时左边补符号位；每右移1位，相当于/2</dd>
                <dd class="mt2">[<span class="iconfont icon-wenq warn"></span>]求128和64的逻辑或|</dd>
                <dd>[<span class="iconfont icon-wenq warn"></span>]求256和256的逻辑异或^[如何利用特性快速求解?]</dd>
                <dd>[<span class="iconfont icon-wenq warn"></span>]求254的逻辑非~[注意：补码的符号位；结果为-255]</dd>
                <dd>[<span class="iconfont icon-wenq warn"></span>]求-254的逻辑非~[注意：补码的符号位；结果为244]</dd>
                <dd>[<span class="iconfont icon-wenq warn"></span>]求32 >> 2</dd>
                <dd>[<span class="iconfont icon-wenq warn"></span>]求-32 >> 2</dd>
            </dl>
        </div>
        <div class="cont-wrap">
            <div class="chap">优先级</div>
            <dl>
                <dd>算术优先级：先*/后+-</dd>
                <dd>算术运算符 &lt; 赋值运算符，因为要先计算出结果才赋值</dd>
                <dd>尽量使用()提升或者明确优先级，以增加代码可读性</dd>
            </dl>
        </div>
        <a class="back" href="#top"><span class="iconfont icon-Arrowup"></span></a>
        <iframe src="../common/hotlinksJava.html" frameborder="0" scrolling="no"
            onload="this.height=this.contentDocument.body.scrollHeight"></iframe>
        <iframe src="../common/footer.html" frameborder="0" scrolling="no"
            onload="this.height=this.contentDocument.body.scrollHeight"></iframe>
        <script>
            window.onload = function () {
                let nav = document.querySelector("nav");
                let navItems = document.querySelectorAll('.nav-item');
                let navConts = document.querySelectorAll('.nav-cont');
                let hotSpot = document.querySelector('.hot-spot');

                navItems.forEach((item, i) => {
                    item.addEventListener('click', () => {
                        hotSpot.style.width = item.getBoundingClientRect().width + 'px';
                        let left = 0;
                        for (let ind = 0; ind < i; ind++) {
                            left += navItems[ind].getBoundingClientRect().width;
                        }
                        hotSpot.style.left = left + 'px';
                        navConts[i].scrollIntoView()
                    })
                })

                window.addEventListener("scroll", () => {
                    nav.classList.toggle("hover", window.scrollY > 150);
                })
            }
        </script>
    </div>
</body>

</html>