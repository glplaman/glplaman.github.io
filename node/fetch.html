<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>网络请求 Fetch</title>
  <link rel="stylesheet" href="../css/common2025.css">
  <base target="_blank">
  <style>
    #img {
      width: 120px;
      height: 120px;
    }
  </style>
</head>

<body>
  <header>
    <h1>网络请求</h1>
    <span>&commat;Fetch</span>
  </header>
  <section>
    <h3>Overview</h3>
    <ul>
      <li>Fetch 是 W3C 的一种请求标准；不是第三方库，与 Vue、JQuery 无关</li>
      <li>是原生的 JavaScript，是 Window 的方法，属于 BOM 范畴</li>
      <li>下一代 Ajax 技术，基于 <a href="./promise.html">Promise</a> 方式处理数据 - 返回结果是 Promise</li>
      <li>语法简介明了；除了IE，多数浏览器都兼容</li>
      <li>既可以访问远程数据，也可以访问本地数据</li>
      <li>需要拼接参数；需要二次封装</li>
      <li>以下各案例使用回调函数 callback，简化代码可以使用 <a href="./asynawait.html">异步等待 asyn-await</a></li>
      <li>更多信息，请访问
        <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">Using_Fetch</a>、
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch">MDN - fetch</a>、
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch_API</a>、
        <a href="https://www.jianshu.com/p/8bb4d09182e5">接口调用 - fetch</a>、
        <a href="https://www.cnblogs.com/zhongyehai/p/12363868.html?ivk_sa=1024320u">fetch - 请求数据</a>
      </li>
    </ul>
    <pre>fetch(url)</pre>
    <pre>console.dir(fetch)</pre>
    <h3>Syntax</h3>
    <ul>
      <li>拿到数据需要 <span class="warn">2次</span> 处理</li>
      <li>第一个 then() 返回的 Response 对象，包含了一些元数据和方法，但不直接包含请求返回的实际数据；要获取实际的 JSON 数据，需要调用 res.json() 方法将 Response 对象解析为 JSON
        数据，并返回一个新的 Promise</li>
      <li>第二个 then() 处理解析后的 JSON 数据</li>
      <li>在响应的原型[[Prototype]] Response中，可以看到相关的函数，他们仍然是一个 Promise 对象，所以需要 <span class="warn">2次</span> 返回才能拿到结果</li>
    </ul>
    <pre>
fetch( url, {
  method: '',
  headers: {
    'Content-Type': 'application/json'
  },
  body: ''
} )
  .then( res => res.json() )
  .then( res => {
    console.log( 'success ', res )
  } )</pre>
    <h3>Configuration</h3>
    <ul>
      <li>method（String）：HTTP 请求方法，Get 获取数据 | Post 提交数据 | Delete 删除数据 | Put 更新数据；默认为 GET</li>
      <li>body（String）：HTTP 请求的参数；POST 时使用</li>
      <li>headers（Object）：HTTP 请求头，如 content-type 的常见值为 application/json、application/x-www-form-urlencoded</li>
    </ul>
    <div class="tips">如果数据是 json 格式，可以省略 header 配置项；具体还要看服务器端的适配情况</div>
    <h3>Response</h3>
    <div>. 根据请求的数据类型，返回的结果分别有：</div>
    <ol>
      <li>res.json()：得到 JSON 对象，同 JSON.parse(responseText) 一样；应用最广泛</li>
      <li>res.text()：得到文字|字符串</li>
      <li>res.formData()：得到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData">FormData</a> 表单对象</li>
      <li>res.blob()：得到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">Blob对象</a>，如图片等多媒体对象</li>
    </ol>
    <div>[<span class="iconfont icon-keyboard"></span>] 获取本地/远程 .json 数据 - 在开发者视图的控制台查看获取结果</div>
    <ul>
      <li>多数静态托管平台做了代理，可以直接访问；否则需要进行代理处理；详细操作请参考<span class="iconfont icon-video"></span> <a
          href="https://www.bilibili.com/video/BV1f3Pje5Ewv/?spm_id_from=333.1387.homepage.video_card.click&vd_source=fe13480e1099e18e9d5f4e25467df4df">fetch
          with json - Bilibili</a></li>
      <pre>
fetch('https://glpla.github.io/utils/data/rank/20240203.json')
  .then(res => res.json())
  .then(res => console.log(res))</pre>
    </ul>
    <div>[<span class="iconfont icon-keyboard"></span>] text()</div>
    <ol>
      <li>请求本地/远程文本文件 .txt</li>
      <pre>
fetch('./tmp.txt')
  .then(res => res.text())
  .then(res => console.log(res))</pre>
      <li>请求本地/远程 .html，实现模块化；不需要写完整的 html 结构，只写业务结构即可；见底部版权</li>
      <pre>
fetch('../../common/drill.html')
.then(res => res.text())
.then(res => {
  document.getElementById('require').innerHTML = res;
})</pre>
    </ol>
    <div>[<span class="iconfont icon-keyboard"></span>] formData() - 请求表单</div>
    <div>[<span class="iconfont icon-keyboard"></span>] blob() - 请求图片并渲染</div>
    <ul>
      <img id="img" src="" alt="blob">
      <pre>
fetch('https://glpla.github.io/utils/avatar/avatar0.png')
  .then(res => res.blob())
  .then(res => img.src = URL.createObjectURL(res))</pre>
      <li>指定 accept 获取特别类型的图片，如去除水印、获取特定类型的图片 - 和浏览器和后端服务器有关</li>
      <li>默认图片，url是png，另存为是avif</li>
      <pre>https://png.pngtree.com/recommend-works/png-clipart/20250101/ourmid/pngtree-cartoon-deer-standing-png-image_14982249.png</pre>
      <li>指定获取为png</li>
      <pre>
fetch('https://png.pngtree.com/recommend-works/png-clipart/20250101/ourmid/pngtree-cartoon-deer-standing-png-image_14982249.png', {
  headers: {
    'Accept': 'image/png'
  }
})
  .then(response => response.blob())
  .then(blob => {
    const url = URL.createObjectURL(blob);
    img.value = url;
    console.log(img.value);

  })
  .catch(error => console.error('Error:', error));
      </pre>
    </ul>
  </section>
  <h2>异常处理</h2>
  <section>
    <ul>
      <li>使用 catch()捕获异常；完整使用</li>
      <pre>
try {
  tryStatements
} catch (exceptionVar) {
  catchStatements
} finally {
  finallyStatements
}</pre>
    </ul>
    <h3>捕获的情况</h3>
    <div>. 网络层面失败，无法发起或完成请求 - A Fetch API promise will be rejected only in case of network failure.</div>
    <ul>
      <li>网络连接失败</li>
      <li>DNS解析失败</li>
    </ul>
    <h3>无法捕获的情况</h3>
    <ul>
      <li>404：资源不存在</li>
      <li>500：服务器本身存在问题，如服务器端代码执行出错、数据库连接失败、服务器配置问题，而不是客户端请求的问题</li>
    </ul>
    <h3>解决方案</h3>
    <ul>
      <li>根据响应状态 ok 判断</li>
      <pre>
ok: true
redirected: false
status: 200
statusText: "OK"
type: "cors"
url: "xxx"</pre>
      <pre>
fetch('xxx')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));</pre>
      <li>根据状态码 status 判断</li>
      <pre>
ok: false
redirected: false
status: 404
statusText: "Not Found"
type: "cors"
url: "xxx"</pre>
      <pre>
fetch('xxx')
  .then(response => {
    if (response.status >= 500 && response.status < 600) {
      throw new Error(`Server error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
  </pre>
      <li>完整请求</li>
      <pre>
fetch('xxx')
.then(response => {
  if (!response.ok) {
    throw new Error('Network response was not ok ' + response.statusText);
  }
  return response.json();
})
.then(data => {
  console.log(data);
})
.catch(error => {
  console.error('There was a problem with the fetch operation:', error);
})
.finally(() => {
  console.log('Fetch operation completed.');
});</pre>
    </ul>
  </section>
  <!-- <div class="chap">Application</div>
  <dl>
    <dd>.以下网络请求，基于 <span class="warn">自建</span> 数据服务器：<a href="./express.html">express</a> 环境下的 <a
        href="./dynamic.html">动态资源服务器</a></dd>
    <dd>.也可以直接使用 <span class="warn">线上</span> 数据服务器 <a href="https://randomuser.me/">Random User</a>、<a
        href="https://jsonplaceholder.typicode.com/">Json Placeholder</a>
    </dd>
    <dd>其它请求方式，需求服务器环境支持</dd>
    <h3>获取数据 GET</h3>
    <dd class="sn">
      <div>C端</div>
      <p>默认获取数据 - 一般是获取所有数据</p>
      <pre>
fetch('https://glpla.github.io/utils/data/rank/20240203.json')
  .then(res => res.json())
  .then(res => console.log(res))</pre>
      <p>使用查询参数 query，直接在 url 后面使用 ? 拼接查询值对，使用 & 拼接多个查询参数；如获取指定数据或分页获取数据</p>
      <pre>
fetch('http://127.0.0.1:3000/test?id=20240507')
  .then(res => res.json())
  .then(res => console.log(res))</pre>
      <p>使用路径参数 params</p>
      <pre>
fetch('http://127.0.0.1:3000/test/20240507')
  .then(res => res.json())
  .then(res => console.log(res))</pre>
      <div>S端</div>
      <pre>
router.get('/', (req, res) => {
  console.log(req.query);
  res.header('Access-Control-Allow-Origin', '*')
  res.json({
    code: 'ok',
    type: 'get',
    data: req.query.id
  })
})
router.get('/:id', (req, res) => {
  console.log('params', req.params);
  res.header('Access-Control-Allow-Origin', '*')
  res.json({
    code: 'ok',
    type: 'get',
    data: req.params.id
  })
})</pre>
    </dd>
    <h3>增加数据 POST</h3>
    <dd>url</dd>
    <dd>method：POST</dd>
    <dd>headers：根据数据类型设置，如 JSON 数据，默认就是 JSON，所以使用 JSON 时，也可以省略 header 的配置</dd>
    <dd>body：传递 JSON 数据，需要使用JSON.stringify(data) 序列化数据；部分框架和部分服务器可以自动完成数据的序列化和解析</dd>
    <dd>服务器使用 request.body 获取数据；Express 早期需要使用额外的依赖 body-parser，现在可以 <span class="warn">直接使用</span> 内置中间件</dd>
    <dd class="sn">
      <div>C端</div>
      <p>传递JSON数据</p>
      <pre>
fetch(url + '/cont', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    id: 20240508,
  })
})
  .then(res => res.json())
  .then(res => console.log(res))</pre>
      <p>传递值对，如表单数据</p>
      <pre>
fetch('http://127.0.0.1:3000/test', {
  method: 'post',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: 'id=20240507'
})
  .then(res => res.json())
  .then(res => console.log(res))</pre>
      <div>S端</div>
      <pre>
router
.use(express.urlencoded({ extended: true }))  // for parsing application/x-www-form-urlencoded
.use(express.json())  // for parsing application/json when POST
      </pre>
      <pre>
router.post('/', (req, res) => {
  console.log('req body', req.body);
  res.json({
    code: 'ok',
    type: 'post',
    data: req.body.id
  })
})</pre>
    </dd>
    <h3>删除数据 DELETE</h3>
    <dd>使用 <span class="warn">路径参数</span>，指定 method 为 DELETE</dd>
    <dd>DELETE 请求通常不需要请求体，但可能需要设置 Content-Type。如果API需要，确保它被正确设置，通常为 'Content-Type': 'application/json' 或 'Content-Type':
      'text/plain'</dd>
    <dd>服务器端需要能够处理 DELETE 请求。有些API可能需要特定的路由或者需要在服务器端有相应的处理逻辑</dd>
    <dd>默认情况下，Node + Express 没有开启 DELETE 请求；需要设置请求头；更多信息，请查看 <a href="./proxy.html">代理 - Proxy</a></dd>
    <dd>
      <pre>res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');</pre>
    </dd>
    <dd class="sn">
      <div>C端</div>
      <pre>
fetch('http://127.0.0.1:3000/test/20240507', {
  method: 'DELETE'
})
  .then(res => res.json())
  .then(res => console.log(res))</pre>
      <div>S端</div>
      <pre>
router.delete('/:id', (req, res) => {
  console.log('params', req.params);
  res.json({
    code: 'ok',
    type: 'delete',
    data: req.params.id
  })
})</pre>
    </dd>
    <h3>更新数据 PUT</h3>
    <dd>同POST；除了指定要修改的数据外，还要以<span class="warn">路径参数</span>的形式指定修改谁的数据</dd>
    <dd class="sn">
      <div>C端</div>
      <pre>
fetch('http://127.0.0.1:3000/test/123', {
  method: 'put',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    id: 20240507
  })
})
  .then(res => res.json())
  .then(res => console.log(res))</pre>
      <div>S端</div>
      <pre>
router.put('/:id', (req, res) => {
  console.log('params', req.params);
  console.log('req body', req.body);
  res.json({
    code: 'ok',
    type: 'delete',
    data: req.params.id
  })
})</pre>
    </dd>
  </dl> -->
  <div id="footer"></div>
  <script src="/utils/custom/footer.js"></script>
  <script>
    const img = document.querySelector('#img')
    fetch('https://glpla.github.io/utils/avatar/avatar9.png')
      .then(res => res.blob())
      .then(res => img.src = URL.createObjectURL(res))
  </script>
</body>

</html>